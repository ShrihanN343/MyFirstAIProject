<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="evaluating-prediction-models-and-their-business-impact" class="level1">
<h1>Evaluating Prediction Models and their Business Impact</h1>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>Since my freshmen year, I’ve been passionate about the worlds of business and computer science - a passion that stems from my love of problem-solving and deriving my own solutions. This project represents one example of how I leverage the resources available to me to enhance my programming skills while learning more about business intelligence through stock forecasting. Forecasting stock prices using sophisticated machine learning algorithms is standard practice in quantitative investing. Based on the literature (find and add citation!!!), performing stock forecasting using machine learning models significantly outperforms traditional statistical models. We observe that the LSTM (Long Short Term Memory) model outperformed the baseline and ARIMA models when tested across five distinct tickers.</p>
</section>
<section id="research-question" class="level3">
<h3 class="anchored" data-anchor-id="research-question">Research Question</h3>
<ul>
<li><p><strong>How has stock forecasting using machine learning changed the landscape of the stock market. What are the potential consequences?</strong> (3 citations)</p>
<ul>
<li>Deep learning models are able to outperform traditional methods of statistical analysis in capturing non-linear patterns as well as volatility. However, there continue to exist challenges with AI in financial markets such as data privacy, ethical concerns, and regulatory compliance. For example, due to AI’s black box nature, regulators may find it difficult to defend decisions, and this raises concerns about transparency. There is a growing need for the adaption of AI skills in financial professions, as well as upgrades to infrastructure in order to integrate new technologies to take full advantage of opportunities.</li>
</ul></li>
</ul>
</section>
<section id="methodology" class="level3">
<h3 class="anchored" data-anchor-id="methodology">Methodology</h3>
<p>Our experiment utilized the following Python packages(list all python packages):</p>
<ul>
<li>yfinance</li>
<li>Numpy</li>
<li>Pandas</li>
<li>Matplotlib</li>
<li>Datetime</li>
<li>OS</li>
<li>Sklearn</li>
<li>Pytorch</li>
</ul>
<p>Transparency in data sourcing is aligned with best practices, and communicates good-faith to the community. We make our repository open to the public, allowing anyone to replicate our results.</p>
<p>2.1. Data Ingestion and Preparation Brainstorming Questions: - Why is it important to tell your reader where the data came from and for what period? How does this build credibility? - Transparency in data sourcing is aligned with best practices, and communicates good-faith to the community. We make our repository open to the public, allowing anyone to replicate our results. - How would you explain “normalization” to someone non-technical? Think of an analogy. Why was this step a necessary choice for your LSTM model specifically, but perhaps less so for the others? - Compressing the data between a range of 0.0 and 1.0, where 0.0 is closely associated with the lowest value data point and 1.0 is closely associated with the highest value data point. Once compressed, the data is all relative to another, and it can be further analyzed with machine learning algorithms and statistical analysis.</p>
<ul>
<li>For the purposes of gathering historical stock performance data, the yfinance python library was utilized. The program checks for empty datasets and invalid tickers. After cleaning, the data is saved to a csv file in a directory (data/raw/) with a specified structure. The processing of the data ensures that the model will be able to analyze and work with the data provided and that unnecessary or unclean data is removed or cleaned.</li>
</ul>
<p>2.2. Model Architectures Brainstorming Questions: - Baseline Model: How would you describe the purpose of a “control group” in an experiment? Think of the baseline model as your scientific control. Why is it crucial to prove your advanced model is better than this very simple “reality check”? - The baseline model serves as a control group when evaluating the performance of the LSTM model. The control group in any experiment is supposed to represent a group that receives no experimental treatment and serves as a constant baseline to compare findings with. The baseline model in the project returns the Naive Last Value, or the stock’s last closing price. This standard behavior can then be used to compare the performance of LSTM and the classical model. - Classical Model (ARIMA): How can you position the ARIMA model as the “industry standard” or the “traditional approach” that you are challenging? What are its conceptual strengths (e.g., statistical foundation) and potential weaknesses (e.g., assumptions about data)? - Before the rise of machine learning, models like ARIMA were the industry standard for time series analysis. Built on well understood mathematical principles, no black box. However, it struggles to learn complex data. ADD TO THIS ANSWER USING STRENGTHS AND WEAKNESSES</p>
<p>Strengths: statistical foundation (auto regression/moving avg), interpretability, effectiveness on linear trends</p>
<ul>
<li>The baseline model has a variety of strenghts, such as its effectiveness on linear trends, a string statistical foundation, and its interpretability.</li>
</ul>
<p>Weaknesses: Assumption of linearity (tries to draw straight lines through complex data), stationarity requirement (its statistical properties like mean and variance are constant over time), struggles with complexity</p>
<ul>
<li><p>However, the baseline model also has several drawbacks. The model struggles with complexity and assumes linearity through non-linear data. Another drawback to be noted is its stationarity requirements.</p>
<ul>
<li>IS STRENGHTS AND WEAKNESSES FOR BASELINE OR CLASSICAL??</li>
</ul></li>
<li><p>LSTM Network: What makes the LSTM model “standard”? Think about its core capability: memory. How does an LSTM’s ability to “remember” long-term patterns in the data make it theoretically better suited for complex systems like stock markets compared to ARIMA?</p>
<ul>
<li>LSTM is a type of a recurrent neural network and it has an internal structure called the memory cell. This cell structure allows the network to learn over time what information is important to keep versus what important is irrelevant to forget.</li>
</ul></li>
</ul>
</section>
<section id="results" class="level3">
<h3 class="anchored" data-anchor-id="results">Results</h3>
<p>3.1. Quantitative Comparison Action: Run the evaluation scripts for all models to populate the RMSE table. Brainstorming Questions: - Before you write, just look at the completed table. What is the most obvious story the numbers are telling? Is there a clear winner? Are there any results that surprise you? - The numbers point to the LSTM being the most accurate model of the three due to it consistently having the lowest RMSE across all tickers. I was surprised to see that despite the differences in the baseline and ARIMA models’ performances, they performed very close when predicting AMZN. In analyzing other tickers, however, the difference was sharp. For example, the ARIMA model had an RMSE of approximately 63 while the baseline model’s RMSE was around 24 for the ticker MSFT. - How can you introduce this table to the reader? Frame it as the primary evidence from your comparative study. - This table provides us with statistical data that compares the performances of all three models across five different ticker symbols of companies that are in a variety of sectors. Each model scores an RMSE value for each ticker. RMSE (root-mean squared error) refers to the average difference in predicted price versus observed price that the stock predicting algorithm makes when forecasting a stock price. The lower the RMSE, the better the model, and the more accurate the forecast.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Stock Ticker</th>
<th>Baseline RMSE</th>
<th>ARIMA RMSE</th>
<th>LSTM RMSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AAPL</td>
<td>13.6648</td>
<td>29.4999</td>
<td>4.8387</td>
</tr>
<tr class="even">
<td>AMZN</td>
<td>14.1469</td>
<td>14.5540</td>
<td>3.7320</td>
</tr>
<tr class="odd">
<td>MSFT</td>
<td>24.2329</td>
<td>62.6977</td>
<td>12.3385</td>
</tr>
<tr class="even">
<td>UNH</td>
<td>46.1457</td>
<td>25.1849</td>
<td>15.6239</td>
</tr>
<tr class="odd">
<td>XOM</td>
<td>6.5515</td>
<td>14.4534</td>
<td>2.4972</td>
</tr>
</tbody>
</table>
<p>3.2. Interpretation of Results Brainstorming Questions: - Tell the Main Story: What’s the headline? Start with the main conclusion from the table. Which model was generally the most accurate? - The LSTM model was the most accurate model across all stocks tested. The baseline model was the second most accurate in predicting all stock values except for UNH. The ARIMA model had the worst overall performance relative to the LSTM and baseline models. - Make it Tangible: Pick one stock (e.g., Apple). What does its RMSE number (4.8387) actually mean in plain English? - RMSE (root-mean squared error) refers to the average difference in predicted price versus observed price that the stock predicting algorithm makes when forecasting a stock price. The lower the RMSE, the better the model, and the more accurate the forecast. - Go Beyond the Numbers: Now look at the graphs in your images/ folder. What do the visuals show you that the RMSE numbers alone don’t? Do the models behave differently during periods of stability versus periods of high volatility? Does one model capture turning points better than another? This is where you can show deep analytical insight. - The LSTM model most accurately predicts shifting market trends and turning points in prices out of all three models. The classical model assumes a “price wall” at the when forecasting stock prices</p>
</section>
<section id="business-implications" class="level3">
<h3 class="anchored" data-anchor-id="business-implications">Business Implications</h3>
<p>Brainstorming Questions: - Think like a consultant. If a company could use your tool, how would it change their business? Move beyond “predicting prices.” Could it be used for risk management? Could it help an analyst check their own biases? Could it automatically flag stocks that are behaving unusually? - Beyond predicting stock prices, machine learning algorithms can also be used to track a business’ inventory and supply chain. Expanding on the Covid-19 example from earlier in the document, an ML application could forecast rising demands for certain goods in times of international emergencies and provide businesses with crucial time to react and be prepared to meet these demands. An ML algorithm can be trained to optimize for a function of social good like reducing scarcity in essential supplies such as toilet paper and cleaning supplies, which were goods affected by scarcity during Covid-19. Future Work Brainstorming Questions: - No project is perfect. What were the limitations you observed? (e.g., the lag during volatility you saw in the charts). How could you address these limitations in a future version? - Future revisions on the LSTM model would include adding hyperparameters to the model to enable more accurate predictions. - What’s the next logical step to make this tool even more powerful? Think about adding more data (like news sentiment), improving the model architecture, or changing the prediction goal (e.g., predicting volatility instead of price).</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>Guidance: A strong conclusion briefly mirrors the introduction. Restate the core problem you set out to solve. Briefly summarize the approach you took (your comparative analysis). State your main, conclusive finding. End on a confident note about the value and potential of your work.</p>
</section>
<section id="acknowledgements" class="level3">
<h3 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h3>
<p>Mr.&nbsp;Zach + citations (at least 10)</p>
<p>Research Question Citations:</p>
<ul>
<li><p>Saberironaghi, Mohammadreza, Jing Ren, and Alireza Saberironaghi. “Stock Market Prediction Using Machine Learning and Deep Learning Techniques: A Review.” AppliedMath, vol.&nbsp;5, no. 3, 2025, p.&nbsp;76. MDPI</p></li>
<li><p>El Hajj, M., &amp; Hammoud, J. “Unveiling the Influence of Artificial Intelligence and Machine Learning on Financial Markets.” Journal of Risk and Financial Management, vol.&nbsp;16, no. 10, MDPI, 2023.</p></li>
<li><p>International Organization of Securities Commissions (IOSCO). Artificial Intelligence in Capital Markets: Use Cases, Risks, and Challenges. IOSCO Consultation Report CR/01/2025, Mar.&nbsp;2025, IOSCO.</p></li>
</ul>
<p>USE THIS SOMEWHERE</p>
<p>Machine learning algorithms can also make predictions on variables that help increase business profits or reduce business expenses. The Covid-19 pandemic highlighted the fragility of domestic supply chains, which could have been mitigated through predictive models of inventory management.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>